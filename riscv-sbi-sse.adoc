== SBI Supervisor Software Events Extension (EID #0x535345 "SSE")

The SBI Supervisor Software Events (SSE) extension provides a
mechanism to inject software events from SBI implementation to
supervisor software such that it preempts all other traps and
interrupts.

The software events can be of two types: local or global. A
local software event is local to a HART and can be handled
only on that HART whereas a global software event is a system
event and can be handled by any HART. 

To handle a software event, the supervisor software MUST
register an event handler and enable it.

Each event handler registered by the supervisor software consist
of two things:

. Handler entry virtual address - The entry virtual address of event
handler code is represented by `handler_entry_virt`. The
`handler_entry_virt` must be a 2-byte aligned address.

. Handler context - The event handler context must be contiguous in
both virtual and physical address space. The virtual address and
physical address of event handler context is represented by
`handler_context_virt` and `handler_context_phys` respectively. The
size of the event handler context is represented by `handler_context_size`.
Both `handler_context_virt` and `handler_context_phys` must be aligned
to (XLEN / 8) bytes whereas `handler_context_size` must be at least 4096
bytes and multiple of (XLEN / 8).

=== Software Event Identification

Each software event is identified by a unique 32-bit unsigned
integer called `event_id` which is encoded as shown in <<table_sse_event_ids>>
below.

[#table_sse_event_ids]
.SSE Event Identification 
[cols="2,3", width=90%, align="center", options="header"]
|===
| Software Event ID            | Description
| 0x00000000                   | Local debug event
| 0x00000001                   | Local RAS event
| 0x00000002                   | Local async page fault event
| 0x00000003                   | Local PMU event
| 0x00000004 - 0x3fffffff      | Reserved for future use
| 0x40000000 - 0x7fffffff      | Local platform specific event
| 0x80000000                   | Global debug event
| 0x80000001                   | Global RAS event
| 0x80000002 - 0xbfffffff      | Reserved for future use
| 0xc0000000 - 0xffffffff      | Global platform specific event
|===

=== Software Event States

At any point in time, a software event can be in one of the
following states:

. **UNUSED**     - Software event is not used by supervisor software
. **REGISTERED** - Supervisor software has provided an event
                    handler for the software event but it is
                    not ready to handle the events.
. **ENABLED**    - Supervisor software is ready to handle the
                    software event.
. **PENDING**    - Software event is pending and not yet delivered
                    to the supervisor software.
. **RUNNING**    - Supervisor software has taken the software
                    event and is busy handling it.

The below diagram shows the state transitions of a software
event.

[#figure_sbi_sse_state_machine]
.SBI SSE State Machine
image::riscv-sbi-sse-sm.png[]

A **global** software event **MUST** be registered and enabled only once by
any HART. By default, a global software event will be routed to any HART
but supervisor software can select a specific HART to handle this event.
The state of a global software event **MUST** be common to all HARTs.

A **local** software event **MUST** be registered and enabled by all HARTs
who want to handle this event. The state of a local software event
**MUST** be tracked separately for each HART.

=== Software Event Handling

To inject a software event on a HART, the SBI implementation must
do the following:

[#sse_stack_setup,reftext=handler stack pointer]
. Compute handler stack pointer (`handler_sp`) which is `XLEN / 8`
  bytes aligned and at least 1024 bytes away from the end of the
  event handler context. For example, an analogous C statement would
  be:

[source, C]
----
  handler_sp = handler_context_virt + handler_context_size - 1024
----

[#sse_save_exception_state,reftext=SSE save exception state]
[start=2]
. Save supervisor register state relative to the handler stack
  pointer (`handler_sp`) in little endian byte ordering as shown
  in <<table_sse_register_saved_state>> below.

[#table_sse_register_saved_state]
.SSE Supervisor Register Saved State On Stack
[cols="5,3", width=90%, align="center", options="header"]
|===
| Handler Stack Offset              | Data
| `handler_sp` + 0 * (XLEN / 8)     | Interrupted program counter
| `handler_sp` + 1 * (XLEN / 8)     | Saved copy of X1
| `handler_sp` + 2 * (XLEN / 8)     | Saved copy of X2
| `handler_sp` + 3 * (XLEN / 8)     | Saved copy of X3
| `handler_sp` + 4 * (XLEN / 8)     | Saved copy of X4
| `handler_sp` + 5 * (XLEN / 8)     | Saved copy of X5
| `handler_sp` + 6 * (XLEN / 8)     | Saved copy of X6
| `handler_sp` + 7 * (XLEN / 8)     | Saved copy of X7
| `handler_sp` + 8 * (XLEN / 8)     | Saved copy of X8
| `handler_sp` + 9 * (XLEN / 8)     | Saved copy of X9
| `handler_sp` + 10 * (XLEN / 8)    | Saved copy of X10
| `handler_sp` + 11 * (XLEN / 8)    | Saved copy of X11
| `handler_sp` + 12 * (XLEN / 8)    | Saved copy of X12
| `handler_sp` + 13 * (XLEN / 8)    | Saved copy of X13
| `handler_sp` + 14 * (XLEN / 8)    | Saved copy of X14
| `handler_sp` + 15 * (XLEN / 8)    | Saved copy of X15
| `handler_sp` + 16 * (XLEN / 8)    | Saved copy of X16
| `handler_sp` + 17 * (XLEN / 8)    | Saved copy of X17
| `handler_sp` + 18 * (XLEN / 8)    | Saved copy of X18
| `handler_sp` + 19 * (XLEN / 8)    | Saved copy of X19
| `handler_sp` + 20 * (XLEN / 8)    | Saved copy of X20
| `handler_sp` + 21 * (XLEN / 8)    | Saved copy of X21
| `handler_sp` + 22 * (XLEN / 8)    | Saved copy of X22
| `handler_sp` + 23 * (XLEN / 8)    | Saved copy of X23
| `handler_sp` + 24 * (XLEN / 8)    | Saved copy of X24
| `handler_sp` + 25 * (XLEN / 8)    | Saved copy of X25
| `handler_sp` + 26 * (XLEN / 8)    | Saved copy of X26
| `handler_sp` + 27 * (XLEN / 8)    | Saved copy of X27
| `handler_sp` + 28 * (XLEN / 8)    | Saved copy of X28
| `handler_sp` + 29 * (XLEN / 8)    | Saved copy of X29
| `handler_sp` + 30 * (XLEN / 8)    | Saved copy of X30
| `handler_sp` + 31 * (XLEN / 8)    | Saved copy of X31
| `handler_sp` + 32 * (XLEN / 8)    | Interrupted state +
                                      **bit[0]** = Privilege mode which
                                                   was interrupted +
                                                  (1 = S-mode, 0 = U-mode) +
                                      **bit[1]** = Virtualization state
                                                  which was interrupted +
                                                 (1 = ON, 0 = OFF) +
                                      **bit[2]** = Saved copy of
                                                   sstatus.SPIE +
                                      **bit[XLEN-1:3]** = Reserved for
                                                          future use
|===

[start=3]
. Update supervisor registers as follows:
   .. Set sp = `handler_sp`
   .. Set a0 = `event_id`
   .. Set a1 = `handler_sp`
   .. Set a2 = `handler_context_virt`
   .. Set sstatus.SPIE = sstatus.SIE
   .. Set sstatus.SIE = 0
. Resume execution with:
   .. Program counter = `handler_entry_virt`
   .. Privilege mode = S-mode
   .. Virtualization state = OFF

=== Software Event Completion

After handling the software event on a HART, the supervisor
software must notify the SBI implementation about completion
of event handling using using sbi_sse_complete() call. The
SBI implementation must do the following to complete event
handling and resume interrupted state:

. Re-compute <<sse_stack_setup>> (`handler_sp`).
. Restore X1 to X31 registers from offsets relative to the
  handler stack pointer (`handler_sp`) as described in
  <<table_sse_register_saved_state>>.
. Update supervisor CSRs as follows:
   .. Set sstatus.SIE = sstatus.SPIE
   .. Set sstatus.SPIE = bit[2] of the value at
                        `handler_sp` + 32 * (XLEN / 8)
. Resume execution with:
   * Virtualization state =  bit[1] of the value at
                            `handler_sp` + 32 * (XLEN / 8)
   * Privilege mode = bit[0] of the value at
                     `handler_sp` + 32 * (XLEN / 8)
   * Program counter = value at `handler_sp` + 0 * (XLEN / 8)

=== Software Event Priority

Each software event has an associated event priority (also
referred as `event_priority`) which can be used by an SBI
implementation to select a software event for injection
when multiple software events are pending on the same HART.

The priority of a software event is a 32-bit unsigned
integer where higher value means higher priority. By default,
all software events have event priority as zero.

A higher priority event, unless disabled by supervisor software,
**always** preempts a lower priority event. Once the higher
priority event is marked as completed, the previous handler will
be resumed.

=== Software Event Attributes

The details of a software event (local or global) can be
accessed by supervisor software inform for event attributes.
Each event attribute is identified using a unique 32-bit
unsigned integer called `attr_id`. The <<table_sse_event_attributes>>
below provides a list event attributes.

[#table_sse_event_attributes]
.SSE Event Attributes
[cols="3,3,5,5", width=90%, align="center", options="header"]
|===
| Attribute ID (attr_id)
| Read-Only
| Description
| Possible values

| 0x00000000
| Yes
| Software event state
| 0: UNUSED +
  1: REGISTERED +
  2: ENABLED +
  3: PENDING +
  4: RUNNING

| 0x00000001
| No
| Software event priority
| 32-bit unsigned integer

| 0x00000002
| Yes
| Supervisor software
| 0: Not allowed +
  1: Allowed [signalling using sbi_sse_signal()]

| 0x00000003
|  No  (global) +
   Yes (local)
| The HART id of HART that should be preferred to handle the global software event
| unsigned long integer

| 0x00000004
| Yes
| Flags for events.
| **Bit[0]:** Raw pending status + 
  **Bit[XLEN-1]:** Reserved.

| > 0x00000004
| ---
| Reserved for future use
| ---
|===

=== Function: Get a software event attribute (FID #0)

[source, C]
----
struct sbiret sbi_sse_get_attr(uint32_t event_id,
                               uint32_t attr_id)
----

Get an event attribute value of software event. The `event_id`
parameter specifies the software event whereas `attr_id` parameter
specifies the event attribute.

Upon success the event attribute value is returned in `sbiret.value`.
On error, the error code is returned in `sbiret.error`. The possible
error values are shown in the <<table_sse_get_attr_errors>> below:

[#table_sse_get_attr_errors]
.SSE Event Attribute Read Errors 
[cols="2,3", width=90%, align="center", options="header"]
|===
| Error code            | Description
| SBI_SUCCESS           | Attribute of given event returned successfully.
| SBI_ERR_INVALID_PARAM | `event_id` or `attr_id` or both are invalid.
|===

=== Function: Set a software event attribute (FID #1)

[source, C]
----
struct sbiret sbi_sse_set_attr(uint32_t event_id,
                               uint32_t attr_id,
                               unsigned long value)
----

Set an event attribute value of software event. The `event_id`
parameter specifies the software event whereas `attr_id` parameter
specifies the event attribute. The new event attribute value is
specified by `value` parameter.

Any error is returned in `sbiret.error`. The possible return values
are listed in <<table_sse_set_attr_errors>> below:

[#table_sse_set_attr_errors]
.SSE Event Attribute Read Errors 
[cols="2,3", width=90%, align="center", options="header"]
|===
| Error code            | Description
| SBI_SUCCESS           | Attribute value set successfully.
| SBI_ERR_INVALID_PARAM | `event_id` or `attr_id` or both are invalid.
|===

=== Function: Register a software event (FID #2)

[source, C]
----
struct sbiret sbi_sse_register(uint32_t event_id,
                               unsigned long handler_entry_virt,
                               unsinged long handler_context_virt,
                               unsigned long handler_context_phys_hi,
                               unsigned long handler_context_phys_lo,
                               unsigned long handler_context_size)
----

Register a handler for a software event. The `event_id` parameter
specifies the event ID for which handler is being registered. The
`handler_entry_virt` is the supervisor mode virtual address of the
handler function. The parameters `handler_context_phys_hi` and
`handler_context_phys_lo` contain the upper and lower XLEN bits,
respectively, of the context's physical address.

NOTE: As described in <<Software Event Handling>>, the handler's context
**MUST** have atleast 1024 bytes, at the end, to be used to save exception
state and to be used as stack.

On successful registration, the event state moves from `UNUSED` to `REGISTERED`.
Any error is returned in `sbiret.error`. The possible error codes are
listed in <<table_sse_register_errors>> below:

[#table_sse_register_errors]
.SSE Event Register Errors
[cols="2,3", width=90%, align="center", options="header"]
|===
| Error code              | Description
| SBI_SUCCESS             | Event handler is registered successfully.
| SBI_ERR_INVALID_PARAM   | `event_id` is invalid.
| SBI_ERR_INVALID_ADDRESS | Permission check failed on handler's context physical address.
|===

=== Function: Unregister a software event (FID #3)

[source, C]
----
struct sbiret sbi_sse_unregister(uint32_t event_id)
----

Unregister the handler for given `event_id`. The event MUST be in `REGISTERED`
state before it can be unregistered and moved to `UNREGISTERED` state. Thus,
the supervisor software MUST disable the event before unregistering.

On successful unregistration, the event is moved to `UNREGISTERED` state.
Any error is returned in `sbiret.error`. The possible error codes are listed in
<<table_sse_unregister_errors>> below:

[#table_sse_unregister_errors]
.SSE Event Unregister Errors
[cols="2,3", width=90%, align="center", options="header"]
|===
| Error code              | Description
| SBI_SUCCESS             | Event handler is unregistered successfully.
| SBI_ERR_FAILED          | Event is not in `REGISTERED` state.
| SBI_ERR_INVALID_PARAM   | `event_id` is invalid.
|===

=== Function: Enable a software event for the calling HART (FID #4)

[source, C]
----
struct sbiret sbi_sse_enable(uint32_t event_id)
----

Enable an event on the calling HART. The `event_id` parameter
refers to the event which should be enabled. A handler must be
registered before calling this function otherwise this function
will fail.

On success, the event is moved to `ENABLED` state and can inject
event when it occurs. Any error is returned in `sbiret.error`.
The possible error codes are listed in <<table_sse_enable_errors>>
below:

[#table_sse_enable_errors]
.SSE Event Enable Errors
[cols="2,3", width=90%, align="center", options="header"]
|===
| Error code              | Description
| SBI_SUCCESS             | Event is successfully enabled.
| SBI_ERR_FAILED          | The event is not in `REGISTERED` state.
| SBI_ERR_ALREADY_STARTED | `event_id` event is already enabled on caller HART
|===

=== Function: Disable a software event for the calling HART (FID #5)

[source, C]
----
struct sbiret sbi_sse_disable(uint32_t event_id)
----

Disable an event on the calling HART. The event ID is provided
by the `event_id` parameter. The calling HART will stop receiving
events of `event_id` type until enabled again. The event must be
in `ENABLED` state before it can be disabled or this function will
fail. Refer <<figure_sbi_sse_state_machine>> for SSE state machine.

If during the call of this function the event becomes pending,
it will be injected.

On success, the event is moved to `REGISTERED` state.
Any error is returned in `sbiret.error`. The possible error codes
are listed in <<table_sse_disable_errors>>.

[#table_sse_disable_errors]
.SSE Event Disable Errors
[cols="2,3", width=90%, align="center", options="header"]
|===
| Error code              | Description
| SBI_SUCCESS             | Event is successfully disabled.
| SBI_ERR_FAILED          | Event is not in `ENABLED` state.
| SBI_ERR_ALREADY_STOPPED | `event_id` event is disabled on caller HART
|===

=== Function: Complete software event handling (FID #6)

[source, C]
----
struct sbiret sbi_sse_complete(uint32_t event_id,
                               unsigned long status)
----

Mark the event referred by parameter `event_id` as handled by
supervisor software. The supervisor software is now ready to
handle the same or lower priority events. Unless marked completed,
the current event (in RUNNING state) or the events of lower
priority, even though in PENDING state, will not be injected.

The supervisor software can disable the `event_id` event on
completion by passing `SBI_SSE_DISABLE_EVENT` in `status`
parameter. If the event is in pending state, it will be
injected. Any future events will not be injected.

Other possible, status codes are listed in <<table_sse_complete_status>>.

[#table_sse_complete_status]
.SSE Event Complete Status Values
[cols="3,2,3", width=90%, align="center", options="header"]
|===
| Enum                    | Value        | Description
| SBI_SSE_CONTINUE_EVENT  | 0            | Continue injecting the event.
| SBI_SSE_DISABLE_EVENT   | 1            | Disable the event.
|===

Any error is returned in `sbiret.error`. The possible error codes
are listed in <<table_sse_complete_errors>>.

[#table_sse_complete_errors]
.SSE Event Complete Errors
[cols="2,3", width=90%, align="center", options="header"]
|===
| Error code              | Description
| SBI_SUCCESS             | Event is successfully marked completed.
| SBI_ERR_FAILED          | The `event_id` event is not in RUNNING state.
|===

=== Function: Signal a software event (FID #7)

[source, C]
----
struct sbiret sbi_sse_inject(uint32_t event_id,
                             unsigned long hart_id)
----

The supervisor software can inject a software event with the
help of this function. The `event_id` paramater refers to the
event to be injected. The `hart_id` parameter refers to the
HART on which the event is to be injected.

The `event_id` event must be enabled on the receiving HART.
The event is immediately injected if no other event is being
handled by the receiving HART or the event is of higher
priority than the one being currently handled. Otherwise,
the event is marked PENDING and injection is deferred until
current event is marked completed.

Any error is returned in `sbiret.error`. The possible error
codes are listed in <<table_sse_inject_errors>>.

[#table_sse_inject_errors]
.SSE Event Inject Errors
[cols="2,3", width=90%, align="center", options="header"]
|===
| Error code              | Description
| SBI_SUCCESS             | Event is successfully injected or marked PENDING
	                    on given HART
| SBI_ERR_FAILED          | The `event_id` event is not in ENABLED state.
|===
