== SBI Supervisor Software Events Extension (EID #0x535345 "SSE")

The SBI Supervisor Software Events (SSE) extension provides a mechanism to
inject software events from an SBI implementation to supervisor software such
that it preempts all other traps and interrupts.

The software events can be of two types: local or global. A local software event
is local to a HART and can be handled only on that HART whereas a global
software event is a system event. A software event can only be handled by a HART
which in the HSM `STARTED` state.

=== Software Event Identification

Each software event is identified by a unique 32-bit unsigned integer called
`event_id` which is encoded as shown in <<table_sse_event_ids>> below.

[#table_sse_event_ids]
.SSE Event Identification
[cols="2,3", width=90%, align="center", options="header"]
|===
| Software Event ID            | Description
| 0x00000000                   | Local RAS event
| 0x00000001                   | Local PMU event
| 0x00000002                   | Local async page fault event
| 0x00000003 - 0x3fffffff      | Reserved for future use
| 0x40000000 - 0x7ffffffe      | Local platform specific event
| 0x7fffffff                   | Local debug event
| 0x80000000                   | Global RAS event
| 0x80000001 - 0xbfffffff      | Reserved for future use
| 0xc0000000 - 0xfffffffe      | Global platform specific event
| 0xffffffff                   | Global debug event
|===

=== Software Event States

At any point in time, a software event can be in one of the
following states:

. **UNUSED**     - Software event is not used by supervisor software
. **REGISTERED** - Supervisor software has provided an event handler for the
                   software event but it is not ready to handle the events.
. **ENABLED**    - Supervisor software is ready to handle the software event.
. **RUNNING**    - Supervisor software has taken the software event and is busy
                   handling it.

The below diagram shows the state transitions of a software event.

[#figure_sbi_sse_state_machine]
.SBI SSE State Machine
image::riscv-sbi-sse-sm.png[]

Each software event is associated with a target HART (referred to as
`target_hart`) which will handle the software event.

A **global** software event **MUST** be registered and enabled only by the
`target_hart` of that software event. The default `target_hart` of a global
software event is assigned by the SBI implementation which can be overridden
by the supervisor software.

A **local** software event **MUST** be registered and enabled by all HARTs which
want to handle the software event. The state of a local software event MUST be
tracked separately for each HART. The `target_hart` for a local software event
is fixed to the associated HART.

=== Software Event Priority

Each software event has an associated event priority (also referred to as
`event_priority`) which can be used by the SBI implementation to select a
software event for injection when multiple software events are pending on the
same HART.

The priority of a software event is a 32-bit unsigned integer where lower value
means higher priority. By default, all software events have event priority as
zero.

If two or more events have same priority on a given hart then SBI implementation
must use `event_id` to break the tie where the lower `event_id` has higher
priority.

A higher priority event always preempts a lower priority event on the same HART.
Once the higher priority event is marked as completed, the previous handler will
be resumed.

NOTE: If a software event in the `RUNNING` state is signaled again by the event
source, the `pending_status` attribute of the event is set. The event is
injected again after the current event completes, provided that supervisor
software doesn't disable the event.

=== Software Event Attributes

A software event can have various attributes associated with it. A software
event attribute is a unique 32-bit unsigned integer called `attr_id`. An
attribute can have Read-Only or Read-Write access permissions. The supervisor
software can query these event attributes and change the attributes that have
Read-Write access permissions.
The <<table_sse_event_attributes>> below provides a list event attributes.

[#table_sse_event_attributes]
.SSE Event Attributes
[cols="3,3,5,5", width=90%, align="center", options="header"]
|===
| Attribute ID (attr_id)
| Read-Only
| Description
| Possible values

| 0x00000000
| Yes
| Software event state
| 0: UNUSED +
  1: REGISTERED +
  2: ENABLED +
  3: RUNNING

| 0x00000001
| No
| Software event priority
| 32-bit unsigned integer

| 0x00000002
| Yes
| Event injection by the supervisor software using `sbi_sse_inject` call.
| 0: Not allowed +
  1: Allowed

| 0x00000003
| No (for global events) +
  Yes (for local events)
| HART id of the `target_hart`.
| unsigned long integer

| 0x00000004
| Yes
| Pending Status
| This is set when the event source signals the event. When the event is
  injected, it is cleared. +
  0: Not Pending
  1: Pending

| > 0x00000004
| ---
| Reserved for future use
| ---
|===

=== Software Event Handler
To handle a software event, the supervisor software MUST register an event
handler and enable it. Each event handler registered by the supervisor software
consists of a handler context (also referred to as `handler_context`).

The `handler_context` contains the following register states:

. **Entry State** - contains the supervisor register state when handling the
  software event injected by SBI implementation. It is referred to as
  `entry_state`. This register state must be initialized by the supervisor
  software before registering the handler. The handler's entry point is at
  offset 0 of the `entry_state` as mentioned in
  <<table_sse_entry_state_reg_offset>>
. **Interrupted State** - contains interrupted register state and is referred to
  as `interrupted_state`. The interrupted execution mode is saved at the end of
  the `interrupted_state`.

The `handler_context`  must be contiguous in both virtual and physical address
space. The physical address of the `handler_context` is represented by
`handler_context_phys_hi` and `handler_context_phys_lo`.

NOTE: It is advisable to use different context for different events. Since a
higher priority event can preempt lower priority events, if same context is
used, then the interrupted state will be overwritten with register values of the
higher priority event. This will make resuming to the previous handler
impossible.

[#table_sse_entry_state_reg_offset]
[cols="5,3", width=90%, align="center", options="header"]
.SSE Register offsets in entry state
|===
| Register Offsets in Entry State      | Data
| `entry_state` + 0 * `(XLEN / 8)`     | Entry program counter +
                                         Must be 2-byte aligned virtual address.
| `entry_state` + 1 * `(XLEN / 8)`     | X1
| `entry_state` + 2 * `(XLEN / 8)`     | X2
| `entry_state` + 3 * `(XLEN / 8)`     | X3
| `entry_state` + 4 * `(XLEN / 8)`     | X4
| `entry_state` + 5 * `(XLEN / 8)`     | X5
| `entry_state` + 6 * `(XLEN / 8)`     | X6
| `entry_state` + 7 * `(XLEN / 8)`     | X7
| `entry_state` + 8 * `(XLEN / 8)`     | X8
| `entry_state` + 9 * `(XLEN / 8)`     | X9
| `entry_state` + 10 * `(XLEN / 8)`    | X10
| `entry_state` + 11 * `(XLEN / 8)`    | X11
| `entry_state` + 12 * `(XLEN / 8)`    | X12
| `entry_state` + 13 * `(XLEN / 8)`    | X13
| `entry_state` + 14 * `(XLEN / 8)`    | X14
| `entry_state` + 15 * `(XLEN / 8)`    | X15
| `entry_state` + 16 * `(XLEN / 8)`    | X16
| `entry_state` + 17 * `(XLEN / 8)`    | X17
| `entry_state` + 18 * `(XLEN / 8)`    | X18
| `entry_state` + 19 * `(XLEN / 8)`    | X19
| `entry_state` + 20 * `(XLEN / 8)`    | X20
| `entry_state` + 21 * `(XLEN / 8)`    | X21
| `entry_state` + 22 * `(XLEN / 8)`    | X22
| `entry_state` + 23 * `(XLEN / 8)`    | X23
| `entry_state` + 24 * `(XLEN / 8)`    | X24
| `entry_state` + 25 * `(XLEN / 8)`    | X25
| `entry_state` + 26 * `(XLEN / 8)`    | X26
| `entry_state` + 27 * `(XLEN / 8)`    | X27
| `entry_state` + 28 * `(XLEN / 8)`    | X28
| `entry_state` + 29 * `(XLEN / 8)`    | X29
| `entry_state` + 30 * `(XLEN / 8)`    | X30
| `entry_state` + 31 * `(XLEN / 8)`    | X31
|===

[#table_sse_interrupted_state_reg_offset]
[cols="5,3", width=90%, align="center", options="header"]
.SSE Register offsets in interrupted state
|===
| Register Offsets in Interrupted State      | Data
| `interrupted_state` + 0 * `(XLEN / 8)`     | Interrupted program counter
| `interrupted_state` + 1 * `(XLEN / 8)`     | Saved copy of X1
| `interrupted_state` + 2 * `(XLEN / 8)`     | Saved copy of X2
| `interrupted_state` + 3 * `(XLEN / 8)`     | Saved copy of X3
| `interrupted_state` + 4 * `(XLEN / 8)`     | Saved copy of X4
| `interrupted_state` + 5 * `(XLEN / 8)`     | Saved copy of X5
| `interrupted_state` + 6 * `(XLEN / 8)`     | Saved copy of X6
| `interrupted_state` + 7 * `(XLEN / 8)`     | Saved copy of X7
| `interrupted_state` + 8 * `(XLEN / 8)`     | Saved copy of X8
| `interrupted_state` + 9 * `(XLEN / 8)`     | Saved copy of X9
| `interrupted_state` + 10 * `(XLEN / 8)`    | Saved copy of X10
| `interrupted_state` + 11 * `(XLEN / 8)`    | Saved copy of X11
| `interrupted_state` + 12 * `(XLEN / 8)`    | Saved copy of X12
| `interrupted_state` + 13 * `(XLEN / 8)`    | Saved copy of X13
| `interrupted_state` + 14 * `(XLEN / 8)`    | Saved copy of X14
| `interrupted_state` + 15 * `(XLEN / 8)`    | Saved copy of X15
| `interrupted_state` + 16 * `(XLEN / 8)`    | Saved copy of X16
| `interrupted_state` + 17 * `(XLEN / 8)`    | Saved copy of X17
| `interrupted_state` + 18 * `(XLEN / 8)`    | Saved copy of X18
| `interrupted_state` + 19 * `(XLEN / 8)`    | Saved copy of X19
| `interrupted_state` + 20 * `(XLEN / 8)`    | Saved copy of X20
| `interrupted_state` + 21 * `(XLEN / 8)`    | Saved copy of X21
| `interrupted_state` + 22 * `(XLEN / 8)`    | Saved copy of X22
| `interrupted_state` + 23 * `(XLEN / 8)`    | Saved copy of X23
| `interrupted_state` + 24 * `(XLEN / 8)`    | Saved copy of X24
| `interrupted_state` + 25 * `(XLEN / 8)`    | Saved copy of X25
| `interrupted_state` + 26 * `(XLEN / 8)`    | Saved copy of X26
| `interrupted_state` + 27 * `(XLEN / 8)`    | Saved copy of X27
| `interrupted_state` + 28 * `(XLEN / 8)`    | Saved copy of X28
| `interrupted_state` + 29 * `(XLEN / 8)`    | Saved copy of X29
| `interrupted_state` + 30 * `(XLEN / 8)`    | Saved copy of X30
| `interrupted_state` + 31 * `(XLEN / 8)`    | Saved copy of X31
| `interrupted_state` + 32 * `(XLEN / 8)`    | Interrupted Execution mode +
                                              **bit [0]** = Privilege mode which
                                              was interrupted +
                                              (1 = S-mode, 0 = U-mode) +
                                              **bit [1]** = Virtualization state
                                              which was interrupted +
                                              (1 = ON, 0 = OFF) +
                                              **bit [2]** = Saved copy of
                                              sstatus.SPIE +
                                              **bit [XLEN-1:3]** = Reserved for
                                              future use
|===

=== Software Event Injection

To inject a software event on a HART, the SBI implementation must
do the following:

. Copy X1 to X31 registers into the `interrupted_state` in `handler_context`
  from the offsets mentioned in <<table_sse_interrupted_state_reg_offset>>.
. Load X1 to X31 registers from `entry_state` in `handler_context` from the
  offsets mentioned in <<table_sse_entry_state_reg_offset>>.
. Save the interrupted mode at offset `interrupted_state` + 32 * `(XLEN / 8)`
  in `handler_context` as shown in <<table_sse_interrupted_state_reg_offset>>.
. Update registers as follows:
   .. Set sstatus.SPIE = sstatus.SIE
   .. Set sstatus.SIE = 0
. Resume execution with:
   .. Program counter = value at `entry_state` + 0 * `(XLEN / 8)`
   .. Privilege mode = S-mode
   .. Virtualization state = OFF

=== Software Event Completion

After handling the software event on a HART, the supervisor software must notify
the SBI implementation about completion of event handling using
`sbi_sse_complete` call. The SBI implementation must do the following to
complete event handling and resume interrupted state:

. Restore X1 to X31 registers from the `interrupted_state` of `handler_context`
  from the offsets mentioned in <<table_sse_interrupted_state_reg_offset>>.
. Update supervisor CSRs as follows:
   .. Set sstatus.SIE = sstatus.SPIE
   .. Set sstatus.SPIE = bit[2] of the value at
                        `interrupted_state` + 32 * `(XLEN / 8)`
. Resume execution with:
   * Virtualization state =  bit[1] of the value at
                            `interrupted_state` + 32 * `(XLEN / 8)`
   * Privilege mode = bit[0] of the value at
                     `interrupted_state` + 32 * `(XLEN / 8)`
   * Program counter = value at `interrupted_state` + 0 * `(XLEN / 8)`

If the supervisor software wishes to resume from a different location, it can
update the `interrupted_state` fields accordingly.

=== Function: Get a software event attribute (FID #0)

[source, C]
----
struct sbiret sbi_sse_get_attr(uint32_t event_id,
                               uint32_t attr_id)
----

Get an event attribute value of a software event. The `event_id` parameter
specifies the software event whereas `attr_id` parameter specifies the software
event's attribute.

Upon success, the event attribute value is returned in `sbiret.value`. In case
of an error, the possible error codes are shown in the
<<table_sse_get_attr_errors>> below:

[#table_sse_get_attr_errors]
.SSE Event Attribute Read Errors
[cols="2,3", width=90%, align="center", options="header"]
|===
| Error code            | Description
| SBI_SUCCESS           | Attribute of given event returned successfully.
| SBI_ERR_INVALID_PARAM | `event_id`, `attr_id` or both are invalid.
|===

=== Function: Set a software event attribute (FID #1)

[source, C]
----
struct sbiret sbi_sse_set_attr(uint32_t event_id,
                               uint32_t attr_id,
                               unsigned long value)
----

Set an event attribute value of a software event. The `event_id` parameter
specifies the software event whereas `attr_id` parameter specifies the event
attribute. The new event attribute value is specified by the `value` parameter.

If the software event specified by the parameter `event_id` is a global software
event and is in the `RUNNING` state, the `target_hart` attribute for the
software event cannot be set. In such case, supervisor software can retry.

NOTE: If the `target_hart` of a global event changes then it doesn't affect the
state of the global event.

An error is returned in `sbiret.error`. In case of error, The possible return
values are listed in <<table_sse_set_attr_errors>> below:

[#table_sse_set_attr_errors]
.SSE Event Attribute Write Errors
[cols="2,3", width=90%, align="center", options="header"]
|===
| Error code            | Description
| SBI_SUCCESS           | Attribute value set successfully.
| SBI_ERR_INVALID_PARAM | `event_id`, `attr_id` or both are invalid
| SBI_ERR_BAD_RANGE     | `value` does not match the possible values
                           defined in <<table_sse_event_attributes>>.
| SBI_ERR_BUSY          | Failed to set attribute value. Supervisor software
                          can retry.
| SBI_ERR_DENIED        | The attribute is read-only.
|===

=== Function: Register a software event (FID #2)

[source, C]
----
struct sbiret sbi_sse_register(uint32_t event_id,
                               unsigned long handler_context_phys_hi,
                               unsigned long handler_context_phys_lo)
----

Register a handler for the software event. The `event_id` parameter specifies
the event ID for which the handler is being registered. The parameters
`handler_context_phys_hi` and `handler_context_phys_lo` contain the upper and
the lower XLEN bits, respectively, of the handler's context. The
`handler_context_phys_lo` parameter must be `(XLEN / 8)` byte aligned.

If the software event specified by the parameter `event_id` is a global event,
the registration of the event handler can only be done by the `target_hart` of
the software event.

On successful registration, the event state moves from `UNUSED` to `REGISTERED`.
In case of an error, possible error codes are listed in
<<table_sse_register_errors>> below:

[#table_sse_register_errors]
.SSE Event Register Errors
[cols="2,3", width=90%, align="center", options="header"]
|===
| Error code              | Description
| SBI_SUCCESS             | Event handler is registered successfully.
| SBI_ERR_INVALID_STATE   | The event is not in `UNUSED` state.
| SBI_ERR_INVALID_PARAM   | `event_id` is invalid or other parameters not satisfy
                             requirements defined in <<_software_event_handler>>.
| SBI_ERR_INVALID_ADDRESS | The memory pointed by `handler_context_phys_lo`,
                            `handler_context_phys_hi`, parameters does not
                             satisfy the requirements described in
                             <<_shared_memory_physical_address_range_parameter>>
                             or the `handler_context_phys_lo` parameter is not
                             `(XLEN / 8)` byte aligned.
| SBI_ERR_DENIED          | `event_id` is a global event and the calling HART id
                            is not the `target_hart` for the software event.
|===

=== Function: Unregister a software event (FID #3)

[source, C]
----
struct sbiret sbi_sse_unregister(uint32_t event_id)
----

Unregister the handler for the given `event_id`. The event MUST be in the
`REGISTERED` state before it can be unregistered.

If the software event specified by the parameter `event_id` is a global event,
the event handler can only be unregistered by the `target_hart` of the software
event.

On successful unregistration, the event is moved to the `UNREGISTERED` state.
In case of an error, possible error codes are listed in
<<table_sse_unregister_errors>> below:

[#table_sse_unregister_errors]
.SSE Event Unregister Errors
[cols="2,3", width=90%, align="center", options="header"]
|===
| Error code              | Description
| SBI_SUCCESS             | Event handler is unregistered successfully.
| SBI_ERR_INVALID_STATE   | Event is not in `REGISTERED` state.
| SBI_ERR_INVALID_PARAM   | `event_id` is invalid.
| SBI_ERR_DENIED          | `event_id` is a global event and the calling HART id
                            is not the `target_hart` for the software event.
|===

=== Function: Enable a software event (FID #4)

[source, C]
----
struct sbiret sbi_sse_enable(uint32_t event_id)
----

Enable the software event specified by the `event_id` parameter. For local
events, the event is enabled only for the calling HART. For global events, the
event can only be enabled by the `target_hart` of the event.

The event MUST be in the `REGISTERED` state otherwise this function will fail.

On success, the event is moved to the `ENABLED` state and the SBI implementation
can inject the event when it occurs. In case of an error, possible error codes
are listed in <<table_sse_enable_errors>> below:

[#table_sse_enable_errors]
.SSE Event Enable Errors
[cols="2,3", width=90%, align="center", options="header"]
|===
| Error code              | Description
| SBI_SUCCESS             | Event is successfully enabled.
| SBI_ERR_INVALID_PARAM   | `event_id` is not valid.
| SBI_ERR_INVALID_STATE   | The event is not in the `REGISTERED` state.
| SBI_ERR_DENIED          | `event_id` is a global event and the calling HART id
                            is not the `target_hart` for the software event.
|===

=== Function: Disable a software event (FID #5)

[source, C]
----
struct sbiret sbi_sse_disable(uint32_t event_id)
----

Disable the software event specified by the `event_id` parameter. For local
events, the event is disabled only for the calling HART. For global events, the
event can only be disabled by the `target_hart` of the event. The event must be
in the `ENABLED` state.

On success, the event is moved to the `REGISTERED` state. In case of an error,
possible error codes are listed in <<table_sse_disable_errors>>.

[#table_sse_disable_errors]
.SSE Event Disable Errors
[cols="2,3", width=90%, align="center", options="header"]
|===
| Error code              | Description
| SBI_SUCCESS             | Event is successfully disabled.
| SBI_ERR_INVALID_PARAM   | `event_id` is not valid.
| SBI_ERR_INVALID_STATE   | Event is not in the `ENABLED` state.
| SBI_ERR_DENIED          | `event_id` is a global event and the calling HART id
                            is not the `target_hart` for the software event.
|===

=== Function: Complete software event handling (FID #6)

[source, C]
----
struct sbiret sbi_sse_complete(uint32_t event_id,
                               uint32_t status,
                               uint32_t flags)
----

Complete the supervisor event handling for the event. The event must be in the
`RUNNING` state.

If supervisor software could not handle the event, it must set the `status`
parameter to `SBI_SSE_HANDLER_FAILED`. On success, it must set the `status`
parameter to `SBI_SSE_HANDLER_SUCCESS`. Other possible status codes are listed
in <<table_sse_complete_status>>.

The `flags` parameter represents additional information from supervisor to the
SBI implementation and the <<table_sse_complete_flags>> lists the bit-encoding
for it.

[#table_sse_complete_status]
.SSE Event Complete Status Values
[cols="3,2,3", width=90%, align="center", options="header"]
|===
| Value         | Enum                     | Description
| 0x00000000    | SBI_SSE_HANDLER_SUCCESS  | Supervisor successfully handled the
                                           | event.
| 0x00000001    | SBI_SSE_HANDLER_FAILED   | Supervisor failed to handle the
                                           | event.
| > 0x00000001  | -                        | Reserved
|===

[#table_sse_complete_flags]
.SSE Event Complete Flags Values
[cols="3,2,3", width=90%, align="center", options="header"]
|===
| Flag Name                   | Bits       | Description
| SBI_SSE_EVENT_DISABLE       | 0:0        | Disable the event.
| *RESERVED*                  | 1:(XLEN-1) | All non-zero values are
                                           |  reserved for future use
|===

In case of an error, possible error codes are listed in
<<table_sse_complete_errors>>.

[#table_sse_complete_errors]
.SSE Event Complete Errors
[cols="2,3", width=90%, align="center", options="header"]
|===
| Error code              | Description
| SBI_SUCCESS             | Event is successfully marked completed.
| SBI_ERR_INVALID_PARAM   | `event_id`, `status`, `flags` or all of them have an
                          | invalid value.
| SBI_ERR_INVALID_STATE   | The `event_id` software event is not in RUNNING
                            state.
| SBI_ERR_DENIED          | The `event_id` software event is a global software
                            event and the calling HART id is not the
                            `target_hart` for the software event.
|===

=== Function: Signal a software event (FID #7)

[source, C]
----
struct sbiret sbi_sse_inject(uint32_t event_id,
                             unsigned long hart_id)
----

The supervisor software can inject a software event with the help of this
function. The `event_id` paramater refers to the event to be injected.

For global events, the `hart_id` parameter is ignored and it is injected on the
`target_hart` for the event. For local events, the `hart_id` parameter refers to
the HART on which the event is to be injected. An event can only be injected if
it is allowed by the event attribute as described in
<<table_sse_event_attributes>>.

In case of an error, possible error codes are listed in
<<table_sse_inject_errors>>.

[#table_sse_inject_errors]
.SSE Event Inject Errors
[cols="2,3", width=90%, align="center", options="header"]
|===
| Error code              | Description
| SBI_SUCCESS             | Event is successfully injected or `pending_status`
                            is set on the given hart.
| SBI_ERR_INVALID_PARAM   | `event_id` or `hart_id` or both are invalid.
| SBI_ERR_DENIED          | The event cannot be injected by the supervisor
                            software.
|===
